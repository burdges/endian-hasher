#!/usr/bin/perl

# We generate lib.rs with this script because Rust does not support 
# doc comments generated by macros.  Initially, I also missed that
# Rust's universal function call syntax would let  n.to_le()  be
# written as H::to_le(n), making it compatable with from_le(n) in
# Rust macros.
# file:///usr/local/share/doc/rust/html/book/ufcs.html

open($L,">","lib.rs.not");

print $L <<_EoR_
// Copyright 2016 Jeffrey Burdges.

//! Simple newtype wrappers that support endianness conversions for
//! primitive numeric types when hashing. 
//! 
//! ```
//! extern crate endianhasher;
//!
//! use std::hash::{Hash, SipHasher, Hasher};
//! use endianhasher::{HasherToLE, HasherToBE};
//!
//! let h = HasherToLE(SipHasher24::new())
//! ```

use std::hash::{Hasher}; // Hash

_EoR_


sub conv_hasher{
    my ($i,$t) = @_;
    print $L <<_EoR_;

/// Apply a primitive numeric type's `$m` method before hashing.
pub struct $i<H: Hasher>(H);

impl<H: Hasher> Hasher for $i<H> {
    fn finish(&self) -> u64 { self.0.finish() }
    fn write(&mut self, bytes: &[u8]) { self.0.write(bytes) }

    fn write_u8(&mut self, n: u8) { self.0.write_u8($t) }
    fn write_u16(&mut self, n: u16) { self.0.write_u16($t) }
    fn write_u32(&mut self, n: u32) { self.0.write_u32($t) }
    fn write_u64(&mut self, n: u64) { self.0.write_u64($t) }
    fn write_usize(&mut self, n: usize) { self.0.write_usize($t) }
    fn write_i8(&mut self, n: i8) { self.0.write_i8($t) }
    fn write_i16(&mut self, n: i16) { self.0.write_i16($t) }
    fn write_i32(&mut self, n: i32) { self.0.write_i32($t) }
    fn write_i64(&mut self, n: i64) { self.0.write_i64($t) }
    fn write_isize(&mut self, n: isize) { self.0.write_isize($t) }
}

_EoR_
} // conv_hasher

conv_hasher("HasherToBE", "n.to_be()" );
conv_hasher("HasherToLE", "n.to_be()" );
conv_hasher("HasherFromBE", "from_be(n)" );
conv_hasher("HasherFromLE", "from_le(n)" );
conv_hasher("HasherSwapBytes", "n.swap_bytes()" );


print $L <<_EoR_

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}

_EoR_

close($L);

